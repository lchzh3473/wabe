{"version":3,"file":"fmod-d4b69bb3.js","sources":["../src/fmod.js"],"sourcesContent":["/* eslint-disable no-negated-condition */\n/* eslint-disable init-declarations */\n/* eslint-disable no-undef */\n/* eslint-disable new-cap */\nexport class FMOD {\n  constructor({\n    // preRun = () => prerun(this),\n    onRuntimeInitialized = () => main(this)\n    // INITIAL_MEMORY = 64 * 1024 * 1024\n  } = {}) {\n    this.FMOD = { onRuntimeInitialized };\n    init(this).then(() => {\n      this.gChannel = null;\n      this.gDSP = null;\n      this.gEffects = false;\n      this.gSound = null;\n      this.gSystem = null;\n    });\n    this._loadEndCallback = () => {};\n    this.ready = new Promise(resolve => {\n      this._loadEndCallback = resolve;\n    });\n  }\n  readAsArrayBuffer(arrayBuffer) {\n    // Create a sound that loops\n    const chars = new Uint8Array(arrayBuffer);\n    const outval = {};\n    const exinfo = this.FMOD.CREATESOUNDEXINFO();\n    exinfo.length = chars.length;\n    if (this.gSound) this.gSound.release();\n    const result = this.gSystem.createSound(chars.buffer, this.FMOD.LOOP_OFF | this.FMOD.OPENMEMORY, exinfo, outval);\n    CHECK_RESULT(this, result);\n    this.gSound = outval.val;\n    // delete chars.buffer;\n    // delete chars;\n  }\n  playSound() {\n    const { FMOD: module } = this;\n    if (this.gSound) {\n      const outval = {};\n      let result;\n      result = this.gSystem.playSound(this.gSound, null, false, outval);\n      CHECK_RESULT(this, result);\n      this.gChannel = outval.val;\n      result = this.gChannel.setCallback(channelCallback);\n      CHECK_RESULT(this, result);\n    }\n    function channelCallback(channelcontrol, controltype, callbacktype, _commanddata1, _commanddata2) {\n      if (callbacktype === module.CHANNELCONTROL_CALLBACK_END) {\n        console.log('CALLBACK : Channel Ended');\n        module.gChannel = null;\n      }\n      return module.OK;\n    }\n  }\n}\nasync function init(module) {\n  const script = document.createElement('script');\n  await new Promise((resolve, reject) => {\n    script.src = './fmod/fmodL.js';\n    script.onload = resolve;\n    script.onerror = reject;\n    document.head.appendChild(script);\n  });\n  script.remove();\n  FMODModule(module.FMOD);\n}\nfunction CHECK_RESULT(module, result) {\n  if (result !== module.FMOD.OK) {\n    const msg = `Error!!! '${module.FMOD.ErrorString(result)}'`;\n    // alert(msg);\n    throw msg;\n  }\n}\n// (function() {\n//   // Function called when user drags HTML range slider.\n//   function volumeChanged(val) {\n//     // document.querySelector('#volume_out').value = val;\n//     if (gChannel) {\n//       const result = gChannel.setVolume(parseFloat(val));\n//       CHECK_RESULT(result);\n//     }\n//   }\n//   // Function called when user presses HTML stop all sounds button.\n//   function stopAll() {\n//     const mcgout = {};\n//     let result;\n//     result = gSystem.getMasterChannelGroup(mcgout);\n//     CHECK_RESULT(result);\n//     const mcg = mcgout.val;\n//     result = mcg.stop();\n//     CHECK_RESULT(result);\n//   }\n//   // Function called when user presses HTML toggle effects button.\n//   function toggleEffects() {\n//     const channelGroupOut = {};\n//     let channelGroup,\n//       result;\n//     result = gSystem.getMasterChannelGroup(channelGroupOut);\n//     CHECK_RESULT(result);\n//     channelGroup = channelGroupOut.val;\n//     if (!gDSP) {\n//       // Create the Reverb DSP\n//       const dspOut = {};\n//       result = gSystem.createDSPByType(FMOD.DSP_TYPE_SFXREVERB, dspOut);\n//       CHECK_RESULT(result);\n//       gDSP = dspOut.val;\n//       // Adjust some parameters of the DSP\n//       result = gDSP.setParameterFloat(FMOD.DSP_SFXREVERB_DECAYTIME, 5000.0);\n//       result = gDSP.setParameterFloat(FMOD.DSP_SFXREVERB_WETLEVEL, -3.0);\n//       result = gDSP.setParameterFloat(FMOD.DSP_SFXREVERB_DRYLEVEL, -2.0);\n//       CHECK_RESULT(result);\n//       // Add the DSP to the channel\n//       result = channelGroup.addDSP(FMOD.CHANNELCONTROL_DSP_TAIL, gDSP);\n//       CHECK_RESULT(result);\n//       // document.querySelector('#effects_out').value = 'On';\n//     } else {\n//       result = channelGroup.removeDSP(gDSP);\n//       CHECK_RESULT(result);\n//       gDSP.release();\n//       gDSP = null;\n//       // document.querySelector('#effects_out').value = 'Off';\n//     }\n//   }\n//   // Called from main, on an interval that updates at a regular rate (like in a game loop).\n//   // Prints out information, about the system, and importantly calles System::udpate().\n//   function updateApplication() {\n//     const cpu = {};\n//     let result;\n//     result = gSystem.getCPUUsage(cpu);\n//     CHECK_RESULT(result);\n//     const channelsplaying = {};\n//     result = gSystem.getChannelsPlaying(channelsplaying, null);\n//     CHECK_RESULT(result);\n//     // document.querySelector('#display_out').value = `Channels Playing = ${channelsplaying.val\n//     // } : CPU = dsp ${cpu.dsp.toFixed(2)\n//     // }% stream ${cpu.stream.toFixed(2)\n//     // }% update ${cpu.update.toFixed(2)\n//     // }% total ${(cpu.dsp + cpu.stream + cpu.update).toFixed(2)\n//     // }%`;\n//     const numbuffers = {};\n//     const buffersize = {};\n//     result = gSystem.getDSPBufferSize(buffersize, numbuffers);\n//     CHECK_RESULT(result);\n//     const rate = {};\n//     result = gSystem.getSoftwareFormat(rate, null, null);\n//     CHECK_RESULT(result);\n//     const sysrate = {};\n//     result = gSystem.getDriverInfo(0, null, null, sysrate, null, null);\n//     CHECK_RESULT(result);\n//     const ms = numbuffers.val * buffersize.val * 1000 / rate.val;\n//     // document.querySelector('#display_out2').value = `Mixer rate = ${rate.val}hz : System rate = ${sysrate.val}hz : DSP buffer size = ${numbuffers.val} buffers of ${buffersize.val} samples (${ms.toFixed(2)} ms)`;\n//     // Update FMOD\n//     result = gSystem.update();\n//     CHECK_RESULT(result);\n//   }\n// }());\n// function prerun() {\n//   /* No sounds to load! */\n// }\n// Called when the Emscripten runtime has initialized\nfunction main(module) {\n  const { FMOD: fModule } = module;\n  // A temporary empty object to hold our system\n  const systemOut = {};\n  let result;\n  console.log('Creating FMOD System object\\n');\n  // Create the system and check the result\n  result = fModule.System_Create(systemOut);\n  CHECK_RESULT(module, result);\n  console.log('grabbing system object from temporary and storing it\\n');\n  // Take out our System object\n  module.gSystem = systemOut.val;\n  // Optional.  Setting DSP Buffer size can affect latency and stability.\n  // Processing is currently done in the main thread so anything lower than 2048 samples can cause stuttering on some devices.\n  console.log('set DSP Buffer size.\\n');\n  result = module.gSystem.setDSPBufferSize(2048, 2);\n  CHECK_RESULT(module, result);\n  console.log('initialize FMOD\\n');\n  // 1024 virtual channels\n  result = module.gSystem.init(1024, fModule.CREATESAMPLE, null);\n  CHECK_RESULT(module, result);\n  console.log('initialize Application\\n');\n  // initApplication();\n  // Starting up your typical JavaScript application loop. Set the framerate to 50 frames per second, or 20ms.\n  console.log('Start game loop\\n');\n  // window.setInterval(updateApplication, 20);\n  module._loadEndCallback();\n  return fModule.OK;\n}\nself.makeWAV = function(pcmData = new ArrayBuffer(16), sampleRate = 44100, bits = 16, channels = 1) {\n  const bytes = pcmData.byteLength;\n  const data = new DataView(new ArrayBuffer(bytes + 44));\n  data.setUint32(0, 0x52494646, false); // RIFF\n  data.setUint32(4, bytes + 36, true); // size\n  data.setUint32(8, 0x57415645, false); // WAVE\n  data.setUint32(12, 0x666d7420, false); // fmt\n  data.setUint32(16, 16, true); // 16bit\n  data.setUint16(20, 1, true); // PCM\n  data.setUint16(22, channels, true); // channels\n  data.setUint32(24, sampleRate, true); // sampleRate\n  data.setUint32(28, sampleRate * channels * bits / 8, true); // bytesPerSecond\n  data.setUint16(32, channels * bits / 8, true); // blockAlign\n  data.setUint16(34, bits, true); // bitsPerSample\n  data.setUint32(36, 0x64617461, false); // data\n  data.setUint32(40, bytes, true); // size\n  new Uint8Array(data.buffer, 44).set(new Uint8Array(pcmData));\n  return data.buffer;\n};\nself.playWAV = function(buffer) {\n  const actx = new AudioContext();\n  const source = actx.createBufferSource();\n  actx.decodeAudioData(buffer, ab => {\n    source.buffer = ab;\n    source.connect(actx.destination);\n    source.start();\n  });\n};\n"],"names":["FMOD","constructor","onRuntimeInitialized","t","module","fModule","systemOut","result","console","log","System_Create","CHECK_RESULT","gSystem","val","setDSPBufferSize","init","CREATESAMPLE","_loadEndCallback","OK","main","this","async","script","document","createElement","Promise","resolve","reject","src","onload","onerror","head","appendChild","remove","FMODModule","then","gChannel","gDSP","gEffects","gSound","ready","readAsArrayBuffer","arrayBuffer","chars","Uint8Array","outval","exinfo","CREATESOUNDEXINFO","length","release","createSound","buffer","LOOP_OFF","OPENMEMORY","playSound","setCallback","channelcontrol","controltype","callbacktype","_commanddata1","_commanddata2","CHANNELCONTROL_CALLBACK_END","ErrorString","self","makeWAV","pcmData","ArrayBuffer","sampleRate","bits","channels","bytes","byteLength","data","DataView","setUint32","setUint16","set","playWAV","actx","AudioContext","source","createBufferSource","decodeAudioData","ab","connect","destination","start"],"mappings":"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"}